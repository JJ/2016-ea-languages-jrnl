\documentclass[review]{elsarticle}
\bibliographystyle{elsarticle-num}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\begin{document}

<<setup, cache=FALSE,echo=FALSE>>=
library("ggplot2")
measures <- read.csv('measures.csv')
@ 

\begin{frontmatter}

\title{There is no fast lunch: an examination of the running speed of
  evolutionary algorithms in several languages}

\author[ugr,geneura,osl]{J.J. Merelo\corref{cor1}}
\ead{jmerelo@ugr.es}

\cortext[cor1]{Corresponding author. He can be
    reached at his email address or at the
    \href{https://github.com/geneura-papers/2015-ea-languages/issues}{issues
      section} of the repository for this paper.}
      
      
\date{}

%\maketitle

\begin{abstract}
  It is quite usual when an evolutionary algorithm tool or library
  uses a language other than C, C++, Java or Matlab that a reviewer or
  the audience questions its usefulness based on the speed of those
  other languages, purportedly slower than the aforementioned
  ones. Despite speed being not everything needed to design an useful
  evolutionary algorithm application, in this paper we will measure
  the speed for several very basic evolutionary algorithm operations
  in several languages which use different virtual machines and
  approaches, and prove that, in fact, there is no big difference in
  speed between interpreted and compiled languages, and that in some
  cases, interpreted languages can be faster than compiled languages
  such as Java. Besides, tools used by any analyst such as profilers
  can in fact bring order of magnitude improvements to the speed of an
  evolutionary algorithm.  
\end{abstract}

\begin{keyword}
Evolutionary algorithms, implementation, programming, string handling.
\end{keyword}

\end{frontmatter}

\section{Introduction}

It is a well extended myth in scientific programming to claim that
compiled languages such as C++ or Java are always, in every
circumstance, faster than interpreted languages such as Perl,
JavaScript or Python.

However, while it is quite clear that efficiency matters, as said in
 \cite{anderson2010efficiency}, in general and restricting the concept
 of {\em speed} to {\em speed of 
  the compiled/interpreted application} it might be the case that some
languages are faster to others, as evidenced by benhmarks such as
\cite{prechelt2000empirical,fulghamcomputer}. Taken in general or even
restricting it to some particular set of problems such as floating
point computation, some compiled languages tend to be faster than
interpreted languages.

But, in the same spirit of the {\em There is no free lunch} theorem
\cite{Wolpert-1997-NFL} we can affirm there is a {\em no fast lunch}
theorem for the implementation of evolutionary optimization, in the
sense that, while there are particular languages that might be the
fastests for particular problem sizes and specially fitness functions,
in general the fastest language will have those two dependencies, and,
specially, for non-trivial problem sizes and limiting ourselves to the
realm of evolutionary algorithm operators, scripting languages such as
JavaScript might be as fast or even faster than compiled languages
such as Java.

Coming up next, we will write a brief state of the art of the analysis
of implementations of evolutionary algorithms. Next we will present
the test we have used for this paper and its rationale, and finally we
will present the results of examining four different languages running
the most widely used evolutionary algorithm operator:
mutation. Finally, we will draw the conclusions and present future
lines of work. 

\section{State of the art}


\section{Results and analysis}
\label{sec:res}

\begin{figure}[h!tb]
  \centering
<<results, cache=FALSE,echo=FALSE>>=
ggplot(measures,aes(x=length,y=time,colour=factor(languagerepresentation)))+ geom_line() + geom_point() +  ggtitle("Evolutionary algorithm language benchmarks")+scale_x_log10()+scale_y_log10()
@ 
\caption{Plot of time needed to perform 100K mutations in strings with
lengths increasing by a factor of two from 16 to $2^{15}$. }
\label{fig:time}
\end{figure}

\section{Conclusions}


\section{Acknowledgements}

This paper is part of the open science effort at the university of
Granada. It has been written using {\tt knitr}, and its source as well as
the data used to create it can be downloaded from
\href{https://github.com/geneura-papers/2015-ea-languages}{the GitHub
  repository}. It has been supported in part by  
\href{http://geneura.wordpress.com}{GeNeura Team}. 
  

\bibliographystyle{alpha}
\bibliography{geneura,languages,GA-general}

\end{document}
%%% Local Variables:
%%% ispell-local-dictionary: "english"
%%% hunspell-local-dictionary: "english"
%%% End:% 
